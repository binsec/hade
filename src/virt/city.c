/* Generated by CIL v. 1.7.0 */
/* print_CIL_Input is false */

enum _1_SECRET_$op;
union _1_SECRET_$node;
struct _IO_FILE;
struct _uint128;
struct timeval;
typedef unsigned long __uint64_t;
typedef __uint64_t uint64_t;
typedef uint64_t uint64;
static uint64 HashLen16(uint64 u , uint64 v ) ;
extern void exit(int status ) ;
typedef unsigned char __uint8_t;
typedef __uint8_t uint8_t;
typedef unsigned int __uint32_t;
typedef __uint32_t uint32_t;
typedef uint32_t uint32;
static uint32 Fetch32(char const   *p ) ;
typedef unsigned long size_t;
uint64 CityHash64(char const   *s , size_t len ) ;
typedef uint8_t uint8;
extern int fclose(void *stream ) ;
struct _uint128 {
   uint64 first ;
   uint64 second ;
};
struct timeval {
   long tv_sec ;
   long tv_usec ;
};
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
extern int raise(int sig ) ;
extern void abort() ;
static uint64 HashLen0to16(char const   *s , size_t len ) ;
void k1_i$nit(void) ;
typedef struct _uint128 uint128;
uint128 WeakHashLen32WithSeeds(char const   *s , uint64 a , uint64 b ) ;
extern void *malloc(unsigned long size ) ;
extern int rand() ;
enum _1_SECRET_$op {
    _1_SECRET__load_unsigned_long$left_STA_0$result_STA_0 = 7,
    _1_SECRET__constant_unsigned_long$result_STA_0$value_LIT_0 = 239,
    _1_SECRET__return_unsigned_long$expr_STA_0 = 34,
    _1_SECRET__call$func_LIT_0 = 252,
    _1_SECRET__label$label_LAB_0 = 55,
    _1_SECRET__store_void_star$right_STA_0$left_STA_1 = 235,
    _1_SECRET__goto$label_LAB_0 = 58,
    _1_SECRET__store_unsigned_long$right_STA_0$left_STA_1 = 31,
    _1_SECRET__formal$result_STA_0$value_LIT_0 = 94,
    _1_SECRET__local$result_STA_0$value_LIT_0 = 85,
    _1_SECRET__convert_void_star2void_star$left_STA_0$result_STA_0 = 191
} ;
unsigned char _1_SECRET_$array[1][56]  = { {        _1_SECRET__local$result_STA_0$value_LIT_0,        (unsigned char)8,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        _1_SECRET__formal$result_STA_0$value_LIT_0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        _1_SECRET__convert_void_star2void_star$left_STA_0$result_STA_0,        _1_SECRET__store_void_star$right_STA_0$left_STA_1, 
            _1_SECRET__local$result_STA_0$value_LIT_0,        (unsigned char)16,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        _1_SECRET__constant_unsigned_long$result_STA_0$value_LIT_0,        (unsigned char)8,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        _1_SECRET__store_unsigned_long$right_STA_0$left_STA_1,        _1_SECRET__call$func_LIT_0, 
            (unsigned char)1,        (unsigned char)0,        (unsigned char)0,        (unsigned char)0, 
            _1_SECRET__local$result_STA_0$value_LIT_0,        (unsigned char)24,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        _1_SECRET__local$result_STA_0$value_LIT_0,        (unsigned char)32,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        _1_SECRET__load_unsigned_long$left_STA_0$result_STA_0,        _1_SECRET__store_unsigned_long$right_STA_0$left_STA_1, 
            _1_SECRET__goto$label_LAB_0,        (unsigned char)4,        (unsigned char)0,        (unsigned char)0, 
            (unsigned char)0,        _1_SECRET__local$result_STA_0$value_LIT_0,        (unsigned char)24,        (unsigned char)0, 
            (unsigned char)0,        (unsigned char)0,        _1_SECRET__load_unsigned_long$left_STA_0$result_STA_0,        _1_SECRET__return_unsigned_long$expr_STA_0}};
extern unsigned long strlen(char const   *s ) ;
int main(int argc , char **argv ) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
extern int gettimeofday(struct timeval *tv , void *tz  , ...) ;
void megaInit(void) ;
uint128 WeakHashLen32WithSeeds6(uint64 w , uint64 x , uint64 y , uint64 z , uint64 a ,
                                uint64 b ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int scanf(char const   *format  , ...) ;
uint64 CityHash64WithSeed(char const   *s , size_t len , uint64 seed ) ;
uint128 CityHash128(char const   *s , size_t len ) ;
uint64_t SECRET(unsigned long input ) ;
void k2_i$nit(void) ;
extern float strtof(char const   *str , char const   *endptr ) ;
extern unsigned long strnlen(char const   *s , unsigned long maxlen ) ;
extern double strtod(char const   *str , char const   *endptr ) ;
static unsigned long k3 ;
static uint64 HashLen33to64(char const   *s , size_t len ) ;
static unsigned long k2 ;
static unsigned long k1 ;
extern void *fopen(char const   *filename , char const   *mode ) ;
static unsigned long k0 ;
extern void signal(int sig , void *func ) ;
union _1_SECRET_$node {
   void *_void_star ;
   unsigned long _unsigned_long ;
   int _int ;
};
char const   *_1_SECRET_$strings  =    "";
static uint128 CityMurmur(char const   *s , size_t len , uint128 seed ) ;
uint128 CityHash128WithSeed(char const   *s , size_t len , uint128 seed ) ;
typedef struct _IO_FILE FILE;
static uint64 HashLen17to32(char const   *s , size_t len ) ;
extern int fprintf(struct _IO_FILE *stream , char const   *format  , ...) ;
__inline static uint64 Hash128to64(uint128 const   x ) ;
static uint64 RotateByAtLeast1(uint64 val , int shift ) ;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned long maxlen ) ;
void k0_i$nit(void) ;
static uint64 UNALIGNED_LOAD64(char const   *p ) ;
static uint64 Rotate(uint64 val , int shift ) ;
void k3_i$nit(void) ;
uint64 CityHash64WithSeeds(char const   *s , size_t len , uint64 seed0 , uint64 seed1 ) ;
static uint64 Fetch64(char const   *p ) ;
static uint32 UNALIGNED_LOAD32(char const   *p ) ;
static uint64 ShiftMix(uint64 val ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
void k0_i$nit(void) 
{ 


  {
  k0 = (uint64 const   )0xc3a5c85c97cb3127ULL;
}
}
static uint64 Rotate(uint64 val , int shift ) 
{ 
  uint64 tmp ;

  {
  if (shift == 0) {
    tmp = val;
  } else {
    tmp = (val >> shift) | (val << (64 - shift));
  }
  return (tmp);
}
}
static uint64 HashLen17to32(char const   *s , size_t len ) 
{ 
  uint64 a ;
  uint64 tmp ;
  uint64 b ;
  uint64 tmp___0 ;
  uint64 c ;
  uint64 tmp___1 ;
  uint64 d ;
  uint64 tmp___2 ;
  uint64 tmp___3 ;
  uint64 tmp___4 ;
  uint64 tmp___5 ;
  uint64 tmp___6 ;

  {
  tmp = Fetch64(s);
  a = tmp * (uint64 )k1;
  tmp___0 = Fetch64(s + 8);
  b = tmp___0;
  tmp___1 = Fetch64((s + len) - 8);
  c = tmp___1 * (uint64 )k2;
  tmp___2 = Fetch64((s + len) - 16);
  d = tmp___2 * (uint64 )k0;
  tmp___3 = Rotate(b ^ (unsigned long )k3, 20);
  tmp___4 = Rotate(a - b, 43);
  tmp___5 = Rotate(c, 30);
  tmp___6 = HashLen16((tmp___4 + tmp___5) + d, ((a + tmp___3) - c) + len);
  return (tmp___6);
}
}
__inline static uint64 Hash128to64(uint128 const   x ) 
{ 
  uint64 kMul ;
  uint64 a ;
  uint64 b ;

  {
  kMul = (uint64 )0x9ddfea08eb382d69ULL;
  a = (uint64 )((x.first ^ x.second) * (unsigned long const   )kMul);
  a ^= a >> 47;
  b = (uint64 )((x.second ^ (unsigned long const   )a) * (unsigned long const   )kMul);
  b ^= b >> 47;
  b *= kMul;
  return (b);
}
}
uint64 CityHash64WithSeeds(char const   *s , size_t len , uint64 seed0 , uint64 seed1 ) 
{ 
  uint64 tmp ;
  uint64 tmp___0 ;

  {
  tmp = CityHash64(s, len);
  tmp___0 = HashLen16(tmp - seed0, seed1);
  return (tmp___0);
}
}
uint64 CityHash64WithSeed(char const   *s , size_t len , uint64 seed ) 
{ 
  uint64 tmp ;

  {
  tmp = CityHash64WithSeeds(s, len, (uint64 )k2, seed);
  return (tmp);
}
}
uint64_t SECRET(unsigned long input ) 
{ 
  char _1_SECRET_$locals[40] ;
  union _1_SECRET_$node _1_SECRET_$stack[1][32] ;
  union _1_SECRET_$node *_1_SECRET_$sp[1] ;
  unsigned char *_1_SECRET_$pc[1] ;

  {
  _1_SECRET_$sp[0] = _1_SECRET_$stack[0];
  _1_SECRET_$pc[0] = _1_SECRET_$array[0];
  while (1) {
    switch (*(_1_SECRET_$pc[0])) {
    case _1_SECRET__goto$label_LAB_0: 
    (_1_SECRET_$pc[0]) ++;
    _1_SECRET_$pc[0] += *((int *)_1_SECRET_$pc[0]);
    break;
    case _1_SECRET__local$result_STA_0$value_LIT_0: 
    (_1_SECRET_$pc[0]) ++;
    (_1_SECRET_$sp[0] + 1)->_void_star = (void *)(_1_SECRET_$locals + *((int *)_1_SECRET_$pc[0]));
    (_1_SECRET_$sp[0]) ++;
    _1_SECRET_$pc[0] += 4;
    break;
    case _1_SECRET__store_void_star$right_STA_0$left_STA_1: 
    (_1_SECRET_$pc[0]) ++;
    *((void **)(_1_SECRET_$sp[0] + -1)->_void_star) = (_1_SECRET_$sp[0] + 0)->_void_star;
    _1_SECRET_$sp[0] += -2;
    break;
    case _1_SECRET__constant_unsigned_long$result_STA_0$value_LIT_0: 
    (_1_SECRET_$pc[0]) ++;
    (_1_SECRET_$sp[0] + 1)->_unsigned_long = *((unsigned long *)_1_SECRET_$pc[0]);
    (_1_SECRET_$sp[0]) ++;
    _1_SECRET_$pc[0] += 8;
    break;
    case _1_SECRET__load_unsigned_long$left_STA_0$result_STA_0: 
    (_1_SECRET_$pc[0]) ++;
    (_1_SECRET_$sp[0] + 0)->_unsigned_long = *((unsigned long *)(_1_SECRET_$sp[0] + 0)->_void_star);
    break;
    case _1_SECRET__label$label_LAB_0: 
    (_1_SECRET_$pc[0]) ++;
    break;
    case _1_SECRET__call$func_LIT_0: 
    (_1_SECRET_$pc[0]) ++;
    switch (*((int *)_1_SECRET_$pc[0])) {
    case 1: 
    *((unsigned long *)(_1_SECRET_$locals + 32)) = CityHash64(*((char const   **)(_1_SECRET_$locals + 8)),
                                                              *((unsigned long *)(_1_SECRET_$locals + 16)));
    break;
    }
    _1_SECRET_$pc[0] += 4;
    break;
    case _1_SECRET__formal$result_STA_0$value_LIT_0: 
    (_1_SECRET_$pc[0]) ++;
    switch (*((int *)_1_SECRET_$pc[0])) {
    case 0: 
    (_1_SECRET_$sp[0] + 1)->_void_star = (void *)(& input);
    break;
    }
    (_1_SECRET_$sp[0]) ++;
    _1_SECRET_$pc[0] += 4;
    break;
    case _1_SECRET__store_unsigned_long$right_STA_0$left_STA_1: 
    (_1_SECRET_$pc[0]) ++;
    *((unsigned long *)(_1_SECRET_$sp[0] + -1)->_void_star) = (_1_SECRET_$sp[0] + 0)->_unsigned_long;
    _1_SECRET_$sp[0] += -2;
    break;
    case _1_SECRET__return_unsigned_long$expr_STA_0: 
    (_1_SECRET_$pc[0]) ++;
    return ((_1_SECRET_$sp[0] + 0)->_unsigned_long);
    break;
    case _1_SECRET__convert_void_star2void_star$left_STA_0$result_STA_0: 
    (_1_SECRET_$pc[0]) ++;
    (_1_SECRET_$sp[0] + 0)->_void_star = (_1_SECRET_$sp[0] + 0)->_void_star;
    break;
    }
  }
}
}
static uint32 Fetch32(char const   *p ) 
{ 
  uint32 tmp ;

  {
  tmp = UNALIGNED_LOAD32(p);
  return (tmp);
}
}
void k2_i$nit(void) 
{ 


  {
  k2 = (uint64 const   )0x9ae16a3b2f90404fULL;
}
}
static uint64 RotateByAtLeast1(uint64 val , int shift ) 
{ 


  {
  return ((val >> shift) | (val << (64 - shift)));
}
}
static uint64 Fetch64(char const   *p ) 
{ 
  uint64 tmp ;

  {
  tmp = UNALIGNED_LOAD64(p);
  return (tmp);
}
}
uint64 CityHash64(char const   *s , size_t len ) 
{ 
  uint64 tmp ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 x ;
  uint64 tmp___2 ;
  uint64 y ;
  uint64 tmp___3 ;
  uint64 tmp___4 ;
  uint64 z ;
  uint64 tmp___5 ;
  uint64 tmp___6 ;
  uint64 tmp___7 ;
  uint64 temp ;
  uint128 v ;
  uint128 tmp___8 ;
  uint128 w ;
  uint128 tmp___9 ;
  uint64 tmp___10 ;
  uint64 tmp___11 ;
  uint64 tmp___12 ;
  uint64 tmp___13 ;
  uint64 tmp___14 ;
  uint64 tmp___15 ;
  uint64 tmp___16 ;
  uint64 tmp___17 ;
  uint64 tmp___18 ;
  uint64 tmp___19 ;
  uint64 tmp___20 ;
  uint64 tmp___21 ;

  {
  if (len <= 32UL) {
    if (len <= 16UL) {
      tmp = HashLen0to16(s, len);
      return (tmp);
    } else {
      tmp___0 = HashLen17to32(s, len);
      return (tmp___0);
    }
  } else
  if (len <= 64UL) {
    tmp___1 = HashLen33to64(s, len);
    return (tmp___1);
  }
  tmp___2 = Fetch64((s + len) - 40);
  x = tmp___2;
  tmp___3 = Fetch64((s + len) - 16);
  tmp___4 = Fetch64((s + len) - 56);
  y = tmp___3 + tmp___4;
  tmp___5 = Fetch64((s + len) - 24);
  tmp___6 = Fetch64((s + len) - 48);
  tmp___7 = HashLen16(tmp___6 + len, tmp___5);
  z = tmp___7;
  tmp___8 = WeakHashLen32WithSeeds((s + len) - 64, len, z);
  v = tmp___8;
  tmp___9 = WeakHashLen32WithSeeds((s + len) - 32, y + (uint64 )k1, x);
  w = tmp___9;
  tmp___10 = Fetch64(s);
  x = x * (uint64 )k1 + tmp___10;
  len = (len - 1UL) & 0xffffffffffffffc0UL;
  while (1) {
    tmp___11 = Fetch64(s + 8);
    tmp___12 = Rotate(((x + y) + v.first) + tmp___11, 37);
    x = tmp___12 * (uint64 )k1;
    tmp___13 = Fetch64(s + 48);
    tmp___14 = Rotate((y + v.second) + tmp___13, 42);
    y = tmp___14 * (uint64 )k1;
    x ^= w.second;
    tmp___15 = Fetch64(s + 40);
    y += v.first + tmp___15;
    tmp___16 = Rotate(z + w.first, 33);
    z = tmp___16 * (uint64 )k1;
    v = WeakHashLen32WithSeeds(s, v.second * (uint64 )k1, x + w.first);
    tmp___17 = Fetch64(s + 16);
    w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + tmp___17);
    temp = z;
    z = x;
    x = temp;
    s += 64;
    len -= 64UL;
    if (! (len != 0UL)) {
      break;
    }
  }
  tmp___18 = HashLen16(v.second, w.second);
  tmp___19 = HashLen16(v.first, w.first);
  tmp___20 = ShiftMix(y);
  tmp___21 = HashLen16((tmp___19 + tmp___20 * (uint64 )k1) + z, tmp___18 + x);
  return (tmp___21);
}
}
static uint128 CityMurmur(char const   *s , size_t len , uint128 seed ) 
{ 
  uint64 a ;
  uint64 b ;
  uint64 c ;
  uint64 d ;
  long l ;
  uint64 tmp ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 tmp___2 ;
  uint64 tmp___3 ;
  uint64 tmp___4 ;
  uint64 tmp___5 ;
  uint64 tmp___6 ;
  uint64 tmp___7 ;
  uint64 tmp___8 ;
  uint128 result ;
  uint64 tmp___9 ;

  {
  a = seed.first;
  b = seed.second;
  c = (uint64 )0;
  d = (uint64 )0;
  l = (long )(len - 16UL);
  if (l <= 0L) {
    tmp = ShiftMix(a * (uint64 )k1);
    a = tmp * (uint64 )k1;
    tmp___0 = HashLen0to16(s, len);
    c = b * (uint64 )k1 + tmp___0;
    if (len >= 8UL) {
      tmp___1 = Fetch64(s);
      tmp___2 = tmp___1;
    } else {
      tmp___2 = c;
    }
    d = ShiftMix(a + tmp___2);
  } else {
    tmp___3 = Fetch64((s + len) - 8);
    c = HashLen16(tmp___3 + (uint64 )k1, a);
    tmp___4 = Fetch64((s + len) - 16);
    d = HashLen16(b + len, c + tmp___4);
    a += d;
    while (1) {
      tmp___5 = Fetch64(s);
      tmp___6 = ShiftMix(tmp___5 * (uint64 )k1);
      a ^= tmp___6 * (uint64 )k1;
      a *= (uint64 )k1;
      b ^= a;
      tmp___7 = Fetch64(s + 8);
      tmp___8 = ShiftMix(tmp___7 * (uint64 )k1);
      c ^= tmp___8 * (uint64 )k1;
      c *= (uint64 )k1;
      d ^= c;
      s += 16;
      l -= 16L;
      if (! (l > 0L)) {
        break;
      }
    }
  }
  a = HashLen16(a, c);
  b = HashLen16(d, b);
  result.first = a ^ b;
  tmp___9 = HashLen16(b, a);
  result.second = tmp___9;
  return (result);
}
}
uint128 CityHash128(char const   *s , size_t len ) 
{ 
  uint128 r ;
  uint64 tmp ;
  uint64 tmp___0 ;
  uint128 tmp___1 ;
  uint64 tmp___2 ;
  uint64 tmp___3 ;
  uint128 tmp___4 ;
  uint128 tmp___5 ;

  {
  if (len >= 16UL) {
    tmp = Fetch64(s);
    r.first = tmp ^ (unsigned long )k3;
    tmp___0 = Fetch64(s + 8);
    r.second = tmp___0;
    tmp___1 = CityHash128WithSeed(s + 16, len - 16UL, r);
    return (tmp___1);
  } else
  if (len >= 8UL) {
    tmp___2 = Fetch64(s);
    r.first = tmp___2 ^ len * (size_t )k0;
    tmp___3 = Fetch64((s + len) - 8);
    r.second = tmp___3 ^ (unsigned long )k1;
    tmp___4 = CityHash128WithSeed((char const   *)((void *)0), (size_t )0, r);
    return (tmp___4);
  } else {
    r.first = (uint64 )k0;
    r.second = (uint64 )k1;
    tmp___5 = CityHash128WithSeed(s, len, r);
    return (tmp___5);
  }
}
}
uint128 CityHash128WithSeed(char const   *s , size_t len , uint128 seed ) 
{ 
  uint128 tmp ;
  uint128 v ;
  uint128 w ;
  uint64 x ;
  uint64 y ;
  uint64 z ;
  uint64 temp ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 tmp___2 ;
  uint64 tmp___3 ;
  uint64 tmp___4 ;
  uint64 tmp___5 ;
  uint64 tmp___6 ;
  uint64 tmp___7 ;
  uint64 tmp___8 ;
  uint64 tmp___9 ;
  uint64 tmp___10 ;
  uint64 tmp___11 ;
  uint64 tmp___12 ;
  uint64 tmp___13 ;
  uint64 tmp___14 ;
  uint64 tmp___15 ;
  uint64 tmp___16 ;
  uint64 tmp___17 ;
  uint64 tmp___18 ;
  uint64 tmp___19 ;
  uint64 tmp___20 ;
  uint64 tmp___21 ;
  uint64 tmp___22 ;
  size_t tail_done ;
  uint64 tmp___23 ;
  uint64 tmp___24 ;
  uint64 tmp___25 ;
  uint128 result ;
  uint64 tmp___26 ;
  uint64 tmp___27 ;

  {
  if (len < 128UL) {
    tmp = CityMurmur(s, len, seed);
    return (tmp);
  }
  x = seed.first;
  y = seed.second;
  z = len * (size_t )k1;
  tmp___0 = Rotate(y ^ (unsigned long )k1, 49);
  tmp___1 = Fetch64(s);
  v.first = tmp___0 * (uint64 )k1 + tmp___1;
  tmp___2 = Rotate(v.first, 42);
  tmp___3 = Fetch64(s + 8);
  v.second = tmp___2 * (uint64 )k1 + tmp___3;
  tmp___4 = Rotate(y + z, 35);
  w.first = tmp___4 * (uint64 )k1 + x;
  tmp___5 = Fetch64(s + 88);
  tmp___6 = Rotate(x + tmp___5, 53);
  w.second = tmp___6 * (uint64 )k1;
  while (1) {
    tmp___7 = Fetch64(s + 8);
    tmp___8 = Rotate(((x + y) + v.first) + tmp___7, 37);
    x = tmp___8 * (uint64 )k1;
    tmp___9 = Fetch64(s + 48);
    tmp___10 = Rotate((y + v.second) + tmp___9, 42);
    y = tmp___10 * (uint64 )k1;
    x ^= w.second;
    tmp___11 = Fetch64(s + 40);
    y += v.first + tmp___11;
    tmp___12 = Rotate(z + w.first, 33);
    z = tmp___12 * (uint64 )k1;
    v = WeakHashLen32WithSeeds(s, v.second * (uint64 )k1, x + w.first);
    tmp___13 = Fetch64(s + 16);
    w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + tmp___13);
    temp = z;
    z = x;
    x = temp;
    s += 64;
    tmp___14 = Fetch64(s + 8);
    tmp___15 = Rotate(((x + y) + v.first) + tmp___14, 37);
    x = tmp___15 * (uint64 )k1;
    tmp___16 = Fetch64(s + 48);
    tmp___17 = Rotate((y + v.second) + tmp___16, 42);
    y = tmp___17 * (uint64 )k1;
    x ^= w.second;
    tmp___18 = Fetch64(s + 40);
    y += v.first + tmp___18;
    tmp___19 = Rotate(z + w.first, 33);
    z = tmp___19 * (uint64 )k1;
    v = WeakHashLen32WithSeeds(s, v.second * (uint64 )k1, x + w.first);
    tmp___20 = Fetch64(s + 16);
    w = WeakHashLen32WithSeeds(s + 32, z + w.second, y + tmp___20);
    temp = z;
    z = x;
    x = temp;
    s += 64;
    len -= 128UL;
    if (! (len >= 128UL)) {
      break;
    }
  }
  tmp___21 = Rotate(v.first + z, 49);
  x += tmp___21 * (uint64 )k0;
  tmp___22 = Rotate(w.first, 37);
  z += tmp___22 * (uint64 )k0;
  tail_done = (size_t )0;
  while (tail_done < len) {
    tail_done += 32UL;
    tmp___23 = Rotate(x + y, 42);
    y = tmp___23 * (uint64 )k0 + v.second;
    tmp___24 = Fetch64(((s + len) - tail_done) + 16);
    w.first += tmp___24;
    x = x * (uint64 )k0 + w.first;
    tmp___25 = Fetch64((s + len) - tail_done);
    z += w.second + tmp___25;
    w.second += v.first;
    v = WeakHashLen32WithSeeds((s + len) - tail_done, v.first + z, v.second);
  }
  x = HashLen16(x, v.first);
  y = HashLen16(y + z, w.first);
  tmp___26 = HashLen16(x + v.second, w.second);
  result.first = tmp___26 + y;
  tmp___27 = HashLen16(x + w.second, y + v.second);
  result.second = tmp___27;
  return (result);
}
}
void megaInit(void) 
{ 


  {
  k0_i$nit();
  k1_i$nit();
  k2_i$nit();
  k3_i$nit();
}
}
int main(int argc , char **argv ) 
{ 
  unsigned long input ;
  unsigned long tmp ;
  unsigned long output ;
  uint64_t tmp___0 ;

  {
  megaInit();
  if (argc < 2) {
    printf((char const   */* __restrict  */)"Call this program with 1 arguments\n");
    return (1);
  }
  tmp = strtoul((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)0,
                10);
  input = tmp;
  tmp___0 = SECRET(input);
  output = tmp___0;
  printf((char const   */* __restrict  */)"%lu\n", output);
  return (0);
}
}
static uint64 HashLen0to16(char const   *s , size_t len ) 
{ 
  uint64 a ;
  uint64 tmp ;
  uint64 b ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 tmp___2 ;
  uint64 a___0 ;
  uint32 tmp___3 ;
  uint32 tmp___4 ;
  uint64 tmp___5 ;
  uint8 a___1 ;
  uint8 b___0 ;
  uint8 c ;
  uint32 y ;
  uint32 z ;
  uint64 tmp___6 ;

  {
  if (len > 8UL) {
    tmp = Fetch64(s);
    a = tmp;
    tmp___0 = Fetch64((s + len) - 8);
    b = tmp___0;
    tmp___1 = RotateByAtLeast1(b + len, (int )len);
    tmp___2 = HashLen16(a, tmp___1);
    return (tmp___2 ^ b);
  }
  if (len >= 4UL) {
    tmp___3 = Fetch32(s);
    a___0 = (uint64 )tmp___3;
    tmp___4 = Fetch32((s + len) - 4);
    tmp___5 = HashLen16(len + (a___0 << 3), (uint64 )tmp___4);
    return (tmp___5);
  }
  if (len > 0UL) {
    a___1 = (uint8 )*(s + 0);
    b___0 = (uint8 )*(s + (len >> 1));
    c = (uint8 )*(s + (len - 1UL));
    y = (uint32 )a___1 + ((uint32 )b___0 << 8);
    z = (uint32 )(len + (size_t )((uint32 )c << 2));
    tmp___6 = ShiftMix((uint64 )((unsigned long const   )y * k2 ^ (unsigned long const   )z * k3));
    return (tmp___6 * (uint64 )k2);
  }
  return ((uint64 )k2);
}
}
static uint64 UNALIGNED_LOAD64(char const   *p ) 
{ 
  uint64 result ;

  {
  memcpy((void */* __restrict  */)(& result), (void const   */* __restrict  */)p,
         sizeof(result));
  return (result);
}
}
static uint32 UNALIGNED_LOAD32(char const   *p ) 
{ 
  uint32 result ;

  {
  memcpy((void */* __restrict  */)(& result), (void const   */* __restrict  */)p,
         sizeof(result));
  return (result);
}
}
static uint64 HashLen33to64(char const   *s , size_t len ) 
{ 
  uint64 z ;
  uint64 tmp ;
  uint64 a ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 b ;
  uint64 tmp___2 ;
  uint64 c ;
  uint64 tmp___3 ;
  uint64 tmp___4 ;
  uint64 tmp___5 ;
  uint64 tmp___6 ;
  uint64 vf ;
  uint64 vs ;
  uint64 tmp___7 ;
  uint64 tmp___8 ;
  uint64 tmp___9 ;
  uint64 tmp___10 ;
  uint64 tmp___11 ;
  uint64 tmp___12 ;
  uint64 wf ;
  uint64 ws ;
  uint64 tmp___13 ;
  uint64 r ;
  uint64 tmp___14 ;
  uint64 tmp___15 ;

  {
  tmp = Fetch64(s + 24);
  z = tmp;
  tmp___0 = Fetch64(s);
  tmp___1 = Fetch64((s + len) - 16);
  a = tmp___0 + (len + tmp___1) * (size_t )k0;
  tmp___2 = Rotate(a + z, 52);
  b = tmp___2;
  tmp___3 = Rotate(a, 37);
  c = tmp___3;
  tmp___4 = Fetch64(s + 8);
  a += tmp___4;
  tmp___5 = Rotate(a, 7);
  c += tmp___5;
  tmp___6 = Fetch64(s + 16);
  a += tmp___6;
  vf = a + z;
  tmp___7 = Rotate(a, 31);
  vs = (b + tmp___7) + c;
  tmp___8 = Fetch64(s + 16);
  tmp___9 = Fetch64((s + len) - 32);
  a = tmp___8 + tmp___9;
  z = Fetch64((s + len) - 8);
  b = Rotate(a + z, 52);
  c = Rotate(a, 37);
  tmp___10 = Fetch64((s + len) - 24);
  a += tmp___10;
  tmp___11 = Rotate(a, 7);
  c += tmp___11;
  tmp___12 = Fetch64((s + len) - 16);
  a += tmp___12;
  wf = a + z;
  tmp___13 = Rotate(a, 31);
  ws = (b + tmp___13) + c;
  tmp___14 = ShiftMix((vf + ws) * (uint64 )k2 + (wf + vs) * (uint64 )k0);
  r = tmp___14;
  tmp___15 = ShiftMix(r * (uint64 )k0 + vs);
  return (tmp___15 * (uint64 )k2);
}
}
static uint64 ShiftMix(uint64 val ) 
{ 


  {
  return (val ^ (val >> 47));
}
}
void k3_i$nit(void) 
{ 


  {
  k3 = (uint64 const   )0xc949d7c7509e6557ULL;
}
}
void k1_i$nit(void) 
{ 


  {
  k1 = (uint64 const   )0xb492b66fbe98f273ULL;
}
}
uint128 WeakHashLen32WithSeeds(char const   *s , uint64 a , uint64 b ) 
{ 
  uint64 tmp ;
  uint64 tmp___0 ;
  uint64 tmp___1 ;
  uint64 tmp___2 ;
  uint128 tmp___3 ;

  {
  tmp = Fetch64(s + 24);
  tmp___0 = Fetch64(s + 16);
  tmp___1 = Fetch64(s + 8);
  tmp___2 = Fetch64(s);
  tmp___3 = WeakHashLen32WithSeeds6(tmp___2, tmp___1, tmp___0, tmp, a, b);
  return (tmp___3);
}
}
uint128 WeakHashLen32WithSeeds6(uint64 w , uint64 x , uint64 y , uint64 z , uint64 a ,
                                uint64 b ) 
{ 
  uint64 c ;
  uint64 tmp ;
  uint128 result ;

  {
  a += w;
  b = Rotate((b + a) + z, 21);
  c = a;
  a += x;
  a += y;
  tmp = Rotate(a, 44);
  b += tmp;
  result.first = a + z;
  result.second = b + c;
  return (result);
}
}
static uint64 HashLen16(uint64 u , uint64 v ) 
{ 
  uint128 result ;
  uint64 tmp ;

  {
  result.first = u;
  result.second = v;
  tmp = Hash128to64((uint128 const   )result);
  return (tmp);
}
}
